\chapter{Computer programming}
\label{theway}

The goal of this book is to teach you to think like a computer scientist.
This way of thinking combines some of the best features of mathematics, engineering, and natural science.
Like mathematicians, computer scientists use formal languages to denote ideas, specifically computations.
Like engineers, they design things, assembling components into systems and evaluating trade-offs among alternatives.
And like scientists, they observe the behavior of complex systems, form hypotheses, and test predictions.

\index{problem solving}

An important skill for a computer scientist is {\bf problem solving}.
It involves the ability to formulate problems, think creatively about solutions, and express solutions clearly and accurately.
As it turns out, the process of learning to program computers is an excellent opportunity to develop problem-solving skills.
On one level, you will be learning to program, a useful skill by itself.
On another level, you will use programming as a means to an end.
As we go along, that end will become clearer.


\section{What is a computer?}

Usually when people hear the word computer, they think of a laptop or desktop.
Not surprisingly, searching for ``computer'' on \href{https://images.google.com/}{\tt images.google.com}
displays rows and rows of these types of machines.
However, in a more general sense, a computer can be any type of device that stores and processes data.

\href{http://www.dictionary.com/browse/computer}{\tt Dictionary.com} defines a computer as ``a programmable electronic device designed to accept data, perform prescribed mathematical and logical operations at high speed, and display the results of these operations.
Mainframes, desktop and laptop computers, tablets, and smartphones are some of the different types of computers.''

\index{hardware}
\index{processor}
\index{memory}
\index{CPU}
\index{RAM}

Each type of computer has its own unique design, but internally they all share the same type of {\bf hardware}.
The two most important hardware components are {\bf processors} that perform simple calculations and 
{\bf memory} (or RAM) that temporarily stores information.
Processors are also called CPUs -- central processing units. A modern CPU, however, usually has more than one processor inside it.
Figure~\ref{fig.cpuram} shows what these components look like.

\begin{figure}[!ht]
\begin{center}
%https://commons.wikimedia.org/wiki/File:Intel_80486DX2_top.jpg
\includegraphics[height=11em]{figs/CPU.jpg}
\hspace{2em}
%https://commons.wikimedia.org/wiki/File:Memory_module_DDRAM_20-03-2006.jpg
\includegraphics[height=11em]{figs/RAM.jpg}
\caption{Example processor and memory hardware.}
\label{fig.cpuram}
\end{center}
\end{figure}

In 2018 it's common, even for a smartphone, to have four processors and four gigabytes (four billion cells) of memory.
Users generally see and interact with touchscreens, keyboards, and monitors, but it's the processors and memory that perform the actual computations.

When Netflix rents computers from Amazon.com to offer streaming video,
what Amazon actually provides is access to server machines that have processors and memory, but no screens or keyboards.

Processors and memory is where computing happens, but they are useless without input/ouput (I/O) devices to receive and send data.
Keyboards and screens are I/O devices, as are the Wifi radios embedded in laptops and smartphones.
Servers like Amazon's have one main I/O device: a network interface which ultimately connects to the laptop where you watch movies.
The Go language was designed primarily to program network connected servers.


\section{What is programming?}

\index{program}

A {\bf program} is a sequence of instructions that specifies how to perform a computation on computer hardware.
The computation might be something mathematical, like solving a system of equations or finding the roots of a polynomial.
It could also be a symbolic computation, like searching and replacing text in a document or (strangely enough) compiling a program.

The details look different in different languages, but a few basic instructions appear in just about every language:

\begin{description}
\item[input:] Get data from the keyboard, a file, the network, a camera, or some other device like a temperature sensor.
\item[output:] Display data on the screen, write it to a file, send it over the network, or activate a device like a door lock.
\item[math:] Perform basic mathematical operations like addition and division.
\item[decisions:] Check for certain conditions and execute the appropriate code.
\item[repetition:] Perform some action repeatedly, usually with some variation.
\end{description}

\index{programming}

Believe it or not, that's pretty much all there is to it.
Every program you've ever used, no matter how complicated, is made up of small instructions that look much like these.
So you can think of {\bf programming} as the process of breaking down a large, complex task into smaller and smaller subtasks.
The process continues until the subtasks are simple enough to be performed with the electronic circuits provided by the hardware.

\section{The hello world program}
\label{hello}

Traditionally, the first program you write when learning a new programming language is called the hello world program.
All it does is display the words ``Hello, World!''\ on the terminal.
In Go, it looks like this:

\index{hello.go}

\begin{lstlisting}
package main

import "fmt"

func main() {
	// display traditional greeting
	fmt.Println("Hello, World!") 
}
\end{lstlisting}

The official Go site provides a ``playground'' where you can run simple programs without installing anything.
We typed the {\tt hello.go} program above and saved it in the playground in this URL:

\url{https://play.golang.org/p/ziqS3mE3_nB}

If you open that address in a browser, you'll see a page similar to Figure~\ref{fig.playhello}.

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/play-hello.png}
\caption{The hello world program in the Go playground.}
\label{fig.playhello}
\end{center}
\end{figure}

The page you'll see does not have the text {\tt Hello, World!} in that lower area,
because you need to run the program to see the output it produces.
Click on the blue button labeled {\bf Run}. You may briefly see the message {\tt Waiting for remote server...},
and then the output will be shown:

\begin{stdout}
Hello, World!
\end{stdout}

Notice that the output does not include the quotation marks.


\index{function}
\index{Println function}

Go programs are made up of {\em function} definitions, and functions are made up of {\em statements}.
A {\bf statement} is a line of code that performs a basic action.
The usual way of performing actions is by calling functions that are written by others, such as the Go authors.
So you write functions and your functions, in turn, call other functions.
In the hello world program, this statement calls the {\bf Println} function to display a message on the screen:

\begin{lstlisting}
	fmt.Println("Hello, World!")
\end{lstlisting}

\index{Println}

\java{fmt.Println} displays results on the screen; the name \java{Println} stands for ``print line''.
Confusingly, {\em print} can mean both ``display on the screen'' and ``send to the printer''.
In this book, we'll try to say ``display'' when we mean output to the screen.

\index{case-sensitive}

Go is ``case-sensitive'', which means that uppercase and lowercase are not the same.
In this example, \java{Println} has to begin with an uppercase letter; \java{println} and \java{PRINTLN} won't work.

\index{main function}

A {\bf function} is a sequence of statements.
Functions usually have names, but Go also allows anonymous functions, as we'll see in Chapter XXX.
This code defines a function named \java{main}:

\begin{lstlisting}
func main() {
	// display traditional greeting
	fmt.Println("Hello, World!")
}
\end{lstlisting}

\index{main}

The function name \java{main} is special: when the program runs,
it starts at the first statement in \java{main} and ends when it finishes the last statement.
Later, we will see programs that define more than one function.

\index{\{\} curly braces}
\index{brackets!curly}

Go uses curly braces (\{ and \}) to group things together.
In {\tt hello.go}, the braces contain the body of the function definition.

\index{comment!end-of-line}
\index{statement!comment}

The line that begins with two slashes (\java{//}) is a {\bf comment}, which is a bit of English text that explains the code.
When Go sees \java{//}, it ignores everything from there until the end of the line.
Comments have no effect on the execution of the program, but they make it easier for other programmers (and your future self) to understand what you meant to do.


\index{package}

A {\bf package} is a collection of functions.
The {\tt hello.go} program defines a package named \java{main}. That is also a special name, and it is mandatory for stand-alone programs
--- as opposed to packages designed as parts for larger programs. 

\index{import}

The \java{import} statement declares that our program needs to use the \java{fmt} package, which is part of the Go standard library: a colection of packages providing many ready to use functions. The \java{fmt} name comes from ``format''. The \java{fmt} package has several functions for writing and reading formatted text, such as \java{fmt.Println}.


\section{Compiling Go programs}

\index{high-level language}
\index{language!high-level}

The programming language you will learn in this book is Go, which is a {\bf high-level language}.
Other high-level languages you may have heard of include Java, Python, C, C++, PHP, Ruby, and JavaScript.

\index{machine language}
\index{language!high-level}

Before they can run, programs in high-level languages have to be translated into ``machine language'', the low-level instructions that the computer can follow.
This translation takes some time, which is a small disadvantage of high-level languages.
But high-level languages have two major advantages:

\begin{itemize}

\item It is {\em much} easier to program in a high-level language.
Programs take less time to write, they are shorter and easier to read, and they are more likely to be correct.

\index{portable}

\item High-level languages are {\bf portable}, meaning they can run on different kinds of computers with few or no modifications.
Machine language programs can only run on one kind of computer, and have to be rewritten to run on another.

\end{itemize}

\index{interpret}

Two kinds of programs translate high-level languages into low-level languages: interpreters and compilers.
An {\bf interpreter} reads a high-level program and executes it, meaning that it does what the program says.
It processes the program a little at a time, alternately reading lines and performing computations.
Figure~\ref{fig.interpreter} shows the structure of an interpreter.

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/interpreter.pdf}
\caption{How interpreted languages are executed.}
\label{fig.interpreter}
\end{center}
\end{figure}

\index{compile}
\index{source code}
\index{object code}
\index{executable}

In contrast, a {\bf compiler} reads the entire program and translates it completely before the program starts running.
In this context, the high-level program is called the {\bf source code}, and the translated program is called the {\bf object code} or the {\bf executable}.
Once a program is compiled, you can execute it repeatedly without further translation.
As a result, compiled programs often run faster than interpreted programs.

Figure~\ref{fig.compiler} shows the steps of the development process.
We use the command {\tt go build} to run the Go compile.
It translates {\tt .go} files into binary executable files that store the resulting machine code.
To run the executable, we just call it by name on the command line.

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/compiler.png}
\caption{The process of compiling and running a Go program.}
\label{fig.compiler}
\end{center}
\end{figure}

The programmer writes source code in the file {\tt hello.go} and uses {\tt go build} to compile it.
If there are no errors, the compiler saves the executable in the file {\tt hello} (or {\tt hello.exe}, in Windows).
To run the program, the user simply invokes it in the terminal.
The output of the program is then displayed on the screen.

This is how running {\tt hello.go} looks like on the {\tt bash} shell installed by default on GNU/Linux and Mac OS X machines:

\begin{verbatim}
$ ./hello 
Hello, World!
\end{verbatim}

On the Windows command prompt, it's very similar:

\begin{verbatim}
> hello.exe 
Hello, World!
\end{verbatim}


Although it might seem complicated, these steps are automated for you in most program development environments.
Usually you only have to press a button or type a single command to compile and run your program.
On the other hand, it is important to know what steps are happening in the background,
so if something goes wrong you can figure out what it is.


\section{Displaying two messages}

You can put as many statements as you like in the \java{main} method.
For example, to display more than one line of output:

\begin{lstlisting}
package main

import "fmt"

func main() {
	// display traditional greeting
	fmt.Println("Hello, World!") // first line
	fmt.Println("How are you?")  // another line
}
\end{lstlisting}

As this example shows, you can put comments at the end of a line as well as on lines all by themselves.

\index{quote mark}
\index{string}
\index{type!String}
\index{char}

Phrases that appear in quotation marks are called {\bf strings}, because they contain a sequence of characters strung together in memory.
Characters can be letters, ideograms, numbers, punctuation, symbols, spaces, tabs, emojis, etc.

\index{newline}
\index{Println}

\java{fmt.Println} appends a special character, called a {\bf newline}, that breaks the current line and starts a new one.
If you don't want a newline at the end, you can use \java{fmt.Print} instead of \java{fmt.Print}:

\begin{lstlisting}
package main

import "fmt"

func main() {
	fmt.Print("Goodbye, ")
	fmt.Println("cruel world")
}
\end{lstlisting}

\label{goodbye}

In this example, the first statement does not add a newline, so the output appears on a single line as {\tt Goodbye, cruel world}.
Notice that there is a space at the end of the first string, which appears in the output just before the word cruel.


\section{Formatting source code}
\label{formatting}

In Go source code, some spaces are required.
For example, you need at least one space between words, so this program is not legal:

\begin{verbatim}
packagemain

import"fmt"

funcmain() {
	fmt.Println("Hello, World!") 
}
\end{verbatim}


But most other spaces are optional.
For example, this program {\em is} legal:

\begin{lstlisting}
package main
import "fmt"
func main() {
fmt.Println("Hello, World!") 
}
\end{lstlisting}

However, it's harder to read because the structure of the program is not clear.
Tabs and spaces are important for organizing your program visually, making it easier to understand the program and find errors when they occur.

Go also provides a tool, {\tt gofmt}, which rewrites source code in a standard, readable format. Many editors will automatically run {\tt gofmt} when you save a Go source file. 
% LR: similar for VS Code... For example, in DrJava (see Appendix~\ref{drjava}) you can indent your code by selecting all text ({\sf Ctrl+A}) and pressing the {\sf Tab} key.


\section{Escape sequences}

It's possible to display multiple lines of output with only one line of code.
You just have to tell Go where to put the line breaks.

\begin{lstlisting}
package main

import "fmt"

func main() {
	// display traditional greeting
	fmt.Println("Hello!\nHow are you?")
}
\end{lstlisting}

The output is two lines, each ending with a newline character:

\begin{stdout}
Hello!
How are you doing?
\end{stdout}

\index{escape sequence}

The \verb"\n" is an {\bf escape sequence}, or two characters of source code that represent a single character.
(The backslash allows you to ``escape'' the string to write special characters.)
Notice there is no space between \verb"\n" and \verb"How".
If you add a space there, there will be a space at the beginning of the second line.

\begin{table}[!ht]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\verb"\n" & newline \\
\hline
\verb"\t" & tab \\
\hline
\verb'\"' & double quote \\
\hline
\verb"\\" & backslash \\
\hline
\end{tabular}
\caption{Common escape sequences}
\label{tab:escape}
\end{center}
\end{table}

Go has a total of ten escape sequences, and the four most commonly used ones are listed in Table~\ref{tab:escape}.
For example, to write quotation marks inside of strings, you need to escape them with a backslash.

\begin{code}
fmt.Println("She said \"Hello!\" to me.");
\end{code}

The result is:

\begin{stdout}
She said "Hello!" to me.
\end{stdout}

% LR: 2018-01-10: insert ThPy2e "Formal and natural languages" section here
% Drop next section?

\section{What is computer science?}

This book intentionally omits some details about the Go language (such as the other escape sequences),
because our main goal is learning how to think like a computer scientist.
Being able to understand computation is much more valuable than just learning how to write code.

If you're interested in learning more about Go itself, visit the official website: \url{https://golang.org/}.
The interactive tutorial \href{https://tour.golang.org/welcome/1}{\bf A Tour of Go} is a good place to start.

One of the most interesting aspects of writing programs is deciding how to solve a particular problem, especially when there are multiple solutions.
For example, there are numerous ways to sort a list of numbers, and each way has its advantages.
\href{https://www.toptal.com/developers/sorting-algorithms/}{\tt Sorting-algorithms.com} provides animations and descriptions for eight of the most common ways.
In order to determine which way is best for a given situation, we need techniques for describing and analyzing solutions formally.

\index{algorithm}
\index{computer science}

An {\bf algorithm} is a sequence of steps that specifies how to solve a problem.
Some algorithms are faster than others, and some use less space in computer memory.
{\bf Computer science} is the science of algorithms, including their discovery and analysis.
As you learn to develop algorithms for problems you haven't solved before, you will learn to think like a computer scientist.
%It's much more fun to discover new algorithms than to write the code for solutions that other people came up with!

\index{bug}
\index{debugging}

Designing algorithms and writing code is difficult and error-prone.
For historical reasons, programming errors are called {\bf bugs}, and the process of tracking them down and correcting them is called {\bf debugging}.
As you learn to debug your programs, you will develop new problem-solving skills.
You will need to think creatively when unexpected errors happen.

Although it can be frustrating, debugging is an intellectually rich, challenging, and interesting part of computer science.
In some ways, debugging is like detective work.
You are confronted with clues, and you have to infer the processes and events that led to the results you see.
Thinking about how to correct programs and improve their performance sometimes even leads to the discovery of new algorithms.


\section{Debugging programs}
\label{sec:examples}

It is a good idea to read this book in front of a computer so you can try out the examples as you go.
You can run many of the examples directly in DrJava's Interactions Pane (see Appendix~\ref{interactions}).
But if you put the code in a source file, it will be easier to try out variations.

\index{error!message}

Whenever you are experimenting with a new feature, you should also try to make mistakes.
For example, in the hello world program, what happens if you leave out one of the quotation marks?
What if you leave out both?
What if you spell \java{println} wrong?
These kinds of experiments help you remember what you read.
They also help with debugging, because you learn what the error messages mean.
It is better to make mistakes now and on purpose than later on and accidentally.

\index{experimental debugging}
\index{debugging!experimental}

%\index{Holmes, Sherlock}
%\index{Doyle, Arthur Conan}

Debugging is like an experimental science: once you have an idea about what is going wrong, you modify your program and try again.
If your hypothesis was correct, then you can predict the result of the modification, and you take a step closer to a working program.
If your hypothesis was wrong, you have to come up with a new one.
%As Sherlock Holmes pointed out, ``When you have eliminated the impossible, whatever remains, however improbable, must be the truth.''
%(A.~Conan Doyle, {\em The Sign of Four}.)

Programming and debugging should go hand in hand.
Don't just write a bunch of code and then perform trial and error debugging until it all works.
Instead, start with a program that does {\em something} and make small modifications, debugging them as you go, until the program does what you want.
That way you will always have a working program, and it will be easier to isolate errors.

\index{Linux}
\index{Torvalds, Linus}
\index{Greenfield, Larry}

A great example of this principle is the Linux operating system, which contains millions of lines of code.
It started out as a simple program Linus Torvalds used to explore the Intel 80386 chip.
According to Larry Greenfield in {\it The Linux Users' Guide}, ``One of Linus's earlier projects was a program that would switch between printing AAAA and BBBB.
This later evolved to Linux.''

%Later chapters will make more suggestions about debugging and other programming practices.

Finally, programming sometimes brings out strong emotions.
If you are struggling with a difficult bug, you might feel angry, despondent, or embarrassed.
Remember that you are not alone, and virtually every programmer has had similar experiences.
Don't hesitate to reach out to a friend and ask questions!

%That's why this chapter is called, ``The way of the program''.


\section{Vocabulary}

Throughout the book, we try to define each term the first time we use it.
At the end of each chapter, we include the new terms and their definitions in order of appearance.
If you spend some time learning this vocabulary, you will have an easier time reading the following chapters.

\begin{description}

\term{problem solving}
The process of formulating a problem, finding a solution, and expressing the solution.

\term{hardware}
The electronic and mechanical components of a computer, such as CPUs, RAM, and hard disks.

\term{processor}
A computer chip that performs simple instructions like basic arithmetic and logic.

\term{memory}
Circuits that store data as long as the computer is turn on.
Not to be confused with permanent storage devices like hard disks and flash.

\term{program}
A sequence of instructions that specifies how to perform tasks on a computer.
Also known as software.

\term{programming}
The application of problem solving to creating executable computer programs.

\term{statement}
Part of a program that specifies one step of an algorithm.

\term{print statement}
A statement that causes output to be displayed on the screen.

\term{method}
A named sequence of statements.

\term{class}
For now, a collection of related methods.
(We will see later that there is a lot more to it.)

\term{comment}
A part of a program that contains information about the program but has no effect when the program runs.

\term{high-level language}
A programming language that is designed to be easy for humans to read and write.

\term{low-level language}
A programming language that is designed to be easy for a computer to run.
Also called ``machine language'' or ``assembly language''.

\term{portable}
The ability of a program to run on more than one kind of computer.

\term{interpret}
To run a program in a high-level language by translating it one line at a time and immediately executing the corresponding instructions.

\term{compile}
To translate a program in a high-level language into a low-level language, all at once, in preparation for later execution.

\term{source code}
A program in a high-level language, before being compiled.

\term{object code}
The output of the compiler, after translating the program.

\term{executable}
Another name for object code that is ready to run on specific hardware.

\term{byte code}
A special kind of object code used for Java programs.
Byte code is similar to a low-level language, but it is portable like a high-level language.

\term{string}
A sequence of characters; the primary data type for text.

\term{newline}
A special character signifying the end of a line of text.
Also known as line ending, end of line (EOL), or line break.

%\term{whitespace}
%Newlines, tab characters, and other spaces in a source program.
%Whitespace characters are used to separate words, but other than that, they don't affect the behavior of the program.

\term{escape sequence}
A sequence of code that represents a special character when used inside a string.

\term{algorithm}
A procedure or formula for solving a problem, with or without a computer.

\term{computer science}
The scientific and practical approach to computation and its applications.

\term{bug}
An error in a program.

\term{debugging}
The process of finding and removing errors.

\end{description}


\section{Exercises}

At the end of each chapter, we include exercises you can do with the things you've learned.
We encourage you to at least attempt every problem.
You can't learn to program only by reading about it; you have to practice.

Before you can compile and run Java programs, you might have to download and install a few tools.
There are many good options, but we recommend DrJava, which is an ``integrated development environment'' (IDE) well suited for beginners.
Instructions for getting started are in Appendix~\ref{tools}.

The code for this chapter is in the {\tt ch01} directory of {\tt ThinkJavaCode2}.
See page~\pageref{code} for instructions on how to download the repository.
Before you start the exercises, we recommend that you compile and run the examples.


\begin{exercise}  %%V6 Ex1.1

Computer scientists have the annoying habit of using common English words to mean something other than their common English meaning.
For example, in English, statements and comments are the same thing, but in programs they are different.

\begin{enumerate}
\item In computer jargon, what's the difference between a statement and a comment?
\item What does it mean to say that a program is portable?
\item In common English, what does the word compile mean?
\item What is an executable? Why is that word used as a noun?
\end{enumerate}

The glossary at the end of each chapter is intended to highlight words and phrases that have special meanings in computer science.
When you see familiar words, don't assume that you know what they mean!

\end{exercise}


\begin{exercise}  %%V6 Ex1.2

Before you do anything else, find out how to compile and run a Java program.
Some environments provide sample programs similar to the example in Section~\ref{hello}.

\begin{enumerate}
\item Type in the hello world program, then compile and run it.

\item Add a print statement that displays a second message after the ``Hello, World!''.
Say something witty like, ``How are you?''
Compile and run the program again.

\item Add a comment to the program (anywhere), recompile, and run it again.
The new comment should not affect the result.
\end{enumerate}

This exercise may seem trivial, but it is the starting place for many of the programs we will work with.
To debug with confidence, you will need to have confidence in your programming environment.

In some environments, it is easy to lose track of which program is executing.
You might find yourself trying to debug one program while you are accidentally running another.
Adding (and changing) print statements is a simple way to be sure that the program you are looking at is the program you are running.

\end{exercise}


\begin{exercise}  %%V6 Ex1.3

It is a good idea to commit as many errors as you can think of, so that you see what error messages the compiler produces.
Sometimes the compiler tells you exactly what is wrong, and all you have to do is fix it.
But sometimes the error messages are misleading.
Over time you will develop a sense for when you can trust the compiler and when you have to figure things out yourself.

Starting with the hello world program, try out each of the following errors.
After you make each change, compile the program, read the error message (if there is one), and then fix the error.

\begin{enumerate}
\item Remove one of the open curly braces.
\item Remove one of the close curly braces.
\item Instead of \java{main}, write \java{mian}.
\item Remove the word \java{static}.
\item Remove the word \java{public}.
\item Remove the word \java{System}.
\item Replace \java{println} with \java{Println}.
\item Replace \java{println} with \java{print}.
\item Delete one of the parentheses.
\item Add an extra parenthesis.
\end{enumerate}

\end{exercise}
